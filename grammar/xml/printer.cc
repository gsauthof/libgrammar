// Copyright 2015, Georg Sauthoff <mail@georg.so>

/* {{{ LGPLv3

    This file is part of libgrammar.

    libgrammar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    libgrammar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with libgrammar.  If not, see <http://www.gnu.org/licenses/>.

}}} */
#include "printer.hh"

#include <grammar/version.hh>

#include <sstream>

using namespace std;


namespace grammar {

  namespace xml {

      Printer::Printer(std::ostream &o)
        :
          comment_("\n"),
          o_(o)
      {
      }
      const std::string &Printer::target_namespace() const
      {
        return target_namespace_;
      }
      void Printer::set_target_namespace(const std::string &tn)
      {
        target_namespace_ = tn;
      }
      std::ostream &Printer::o()
      {
        return o_;
      }

      void Printer::print_comment()
      {
        if (comment_.empty())
          return;
        o_ << "<!-- ";
        o_ << "Autogenerated by libgrammar (version " << version::str << ")";
        o_ << comment_ << "  -->\n";
      }
      void Printer::set_comment(int argc, char **argv)
      {
        ostringstream m;
        m << "\nCall was:\n\n";
        if (argc)
          m << '\'' << *argv << '\'';
        for (int i = 1; i < argc; ++i)
          m << " '" << argv[i] << '\'';
        m << "\n\n";
        comment_ += m.str();
      }
      void Printer::set_comment(const std::string &s)
      {
        comment_ = s;
      }

      Printer &operator<<(Printer &o, const Grammar &g)
      {
        o.visit(g);
        return o;
      }
      Printer &operator<<(Printer &o, const Symbol::NT &nt)
      {
        o.visit(nt);
        return o;
      }
      Printer &operator<<(Printer &o, const Constraint::Base &c)
      {
        c.accept(o);
        return o;
      }
      Printer &operator<<(Printer &o, const Constraint::Size &c)
      {
        o.visit(c);
        return o;
      }
      Printer &operator<<(Printer &o, const Symbol::Terminal &terminal)
      {
        o.visit(terminal);
        return o;
      }
      Printer &operator<<(Printer &o, const Rule::Base &rule)
      {
        rule.accept(o);
        return o;
      }
      Printer &operator<<(Printer &o, const Rule::Link &rule)
      {
        o.visit(rule);
        return o;
      }
      Printer &operator<<(Printer &o, const Rule::Sequence &rule)
      {
        o.visit(rule);
        return o;
      }
      Printer &operator<<(Printer &o, const Rule::List &rule)
      {
        o.visit(rule);
        return o;
      }
      Printer &operator<<(Printer &o, const Rule::Set &rule)
      {
        o.visit(rule);
        return o;
      }
      Printer &operator<<(Printer &o, const Rule::Choice &rule)
      {
        o.visit(rule);
        return o;
      }
      Printer &operator<<(Printer &o, const Rule::All &rule)
      {
        o.visit(rule);
        return o;
      }
  }

}
