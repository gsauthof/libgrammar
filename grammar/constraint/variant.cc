/**************************************************************************/
/*
   Autogenerated by the Variant Generator.

   Call was:

     '../variant-generator/build/mkvariant' 'constraint_variant.inf' '--output' 'grammar/constraint/variant.cc'
                                                                          */
/**************************************************************************/
#include "variant.hh"


namespace grammar {
namespace Constraint {

Variant::Variant()
{
}

Variant::Variant(Variant &&o)
{
  switch(o.tag_) {
    case 1:
      new (&enum_) Enum(std::move(o.enum_));
      tag_ = 1;
      break;
    case 2:
      new (&domain_) Domain(std::move(o.domain_));
      tag_ = 2;
      break;
    case 3:
      new (&size_) Size(std::move(o.size_));
      tag_ = 3;
      break;
    case 4:
      new (&pattern_) Pattern(std::move(o.pattern_));
      tag_ = 4;
      break;
  }

}

Variant::~Variant()
{
  destruct();
}

void Variant::destruct()
{
  switch(tag_) {
    case 1: enum_.~Enum(); break;
    case 2: domain_.~Domain(); break;
    case 3: size_.~Size(); break;
    case 4: pattern_.~Pattern(); break;
  }
  tag_ = 0;
}

Variant &Variant::operator=(Variant &&o)
{
  switch(o.tag_) {
    case 1:
      if (tag_ == o.tag_) {
        enum_ = std::move(o.enum_);
      } else {
        destruct();
        new (&enum_) Enum(std::move(o.enum_));
        tag_ = 1;
      }
      break;
    case 2:
      if (tag_ == o.tag_) {
        domain_ = std::move(o.domain_);
      } else {
        destruct();
        new (&domain_) Domain(std::move(o.domain_));
        tag_ = 2;
      }
      break;
    case 3:
      if (tag_ == o.tag_) {
        size_ = std::move(o.size_);
      } else {
        destruct();
        new (&size_) Size(std::move(o.size_));
        tag_ = 3;
      }
      break;
    case 4:
      if (tag_ == o.tag_) {
        pattern_ = std::move(o.pattern_);
      } else {
        destruct();
        new (&pattern_) Pattern(std::move(o.pattern_));
        tag_ = 4;
      }
      break;
  }
  return *this;
}

Variant::Variant(Enum &&o)
  : enum_(std::move(o))
{
  tag_ = 1;
}

Variant::Variant(Domain &&o)
  : domain_(std::move(o))
{
  tag_ = 2;
}

Variant::Variant(Size &&o)
  : size_(std::move(o))
{
  tag_ = 3;
}

Variant::Variant(Pattern &&o)
  : pattern_(std::move(o))
{
  tag_ = 4;
}

Variant &Variant::operator=(Enum &&o)
{
  if (tag_ == 1) {
    enum_ = std::move(o);
  } else {
    destruct();
    new (&enum_) Enum(std::move(o));
    tag_ = 1;
  }
  return *this;
}

Variant &Variant::operator=(Domain &&o)
{
  if (tag_ == 2) {
    domain_ = std::move(o);
  } else {
    destruct();
    new (&domain_) Domain(std::move(o));
    tag_ = 2;
  }
  return *this;
}

Variant &Variant::operator=(Size &&o)
{
  if (tag_ == 3) {
    size_ = std::move(o);
  } else {
    destruct();
    new (&size_) Size(std::move(o));
    tag_ = 3;
  }
  return *this;
}

Variant &Variant::operator=(Pattern &&o)
{
  if (tag_ == 4) {
    pattern_ = std::move(o);
  } else {
    destruct();
    new (&pattern_) Pattern(std::move(o));
    tag_ = 4;
  }
  return *this;
}

} // grammar
} // Constraint

